# Variable Scope
Question 1
What will the following code log to the console and why? 
```js
let num = 5;

function myFunc() {
  num = 10;
}

myFunc();
console.log(num);
```
This logs `10` to the console. The variable `num` declared and initialized to `5` on line 1 is accessible within the scope of the `myFunc` function. When that function is invoked, `num` is reassigned.
***

Question 2
What will the following code log to the console and why? 
```js
let num = 5;

function myFunc() {
  console.log(num);
  num = 10;
}

myFunc();
console.log(num);
```
This first logs `5` to the console, and then logs `10` to the console. The variable `num` declared and initialized to `5` on line 1 is accessible within the scope of the `myFunc` function. When that function is invoked it first logs the value of `num`, which at this point in execution is `5`, and then reassigns `num` to `10`. The reassigned value is then logged on the last line of the code snippet.

Question 3
```js
let num = 5;

function myFunc() {
  let num = 10;
}

myFunc();
console.log(num);
```
Solution 3
This logs `5` to the console. The variable `num` is declared and initialized to `5` on line 1. When the function is executed, however, another variable called `num` is declared and initialized within the scope of the function. The key thing here is that line 4 is the initialization of a new variable rather than the reassignment of the variable from line 1.

Question 4
What will the following code log to the console and why? 
```js
let num = 5;

function myFunc() {
  console.log(num);
  let num = 10;
}

myFunc();
console.log(num);
```
Solution 4
This won't log anything to the console. Instead, this code will raise a `ReferenceError`. The `let` declaration on line `5` creates a new num variable within the scope of the body of the `myFunc` function. The console.log on line 4 is attempting to log the value of that `num` variable, not the one declared and initialized on line one. Since the variable hasn't been initialized yet however, we get a reference error:

Question 5
What will the following code log to the console and why? 
```js
let num = 5;

function myFunc(num) {
  num = 10;
}

myFunc();
console.log(num);
```
Solution 5
This logs `5` to the console. When the `myFunc` function is invoked, due to the function parameter `num` JavaScript creates a new variable `num` within the scope of the function. This variable blocks access to the variable of the same name declared and initialized in the global scope on line 1. That variable cannot therefore be reassigned by the function and so retains its initial value of `5`, which is what is logged.

Question 6
What will the following code log to the console and why? 
```js
let num = 1;

while (num < 3) {
  num += 1;
}

console.log(num);
```
Solution 6
This logs `3` to the console.  The variable `num` declared and initialized on line 1 is incremented by 1 within the while loop on line 4 (this line essentially reassigns num to a new value, which is its current value added to 1). This happens twice, while `num` is less then `3` and so the condition for the `while` loop to execute is met. Once `num` reaches `3`, the while loop no longer runs and so program execution continues to the console.log on line 7, which logs the reassigned value of `num`.

Question 7
What will the following code log to the console and why? 
```js
let num = 1;

while (num < 3) {
  let num = 5;
  num += 1;
}

console.log(num);
```
Solution 7
This doesn't log anything to the console. This code results in an infinite loop, which will eventually time out. Line 4 declares and initializes a variable `num` to the number `5`. This is a different variable to the `num` declared and initialized to 1 on line 1, and exists within the scope of the block defined by the curly braces; it is this `num` that is incremented on line 5. The condition for the while loop, however, references the `num` declared on line 1, not the one within the scope of the block. The condition for ending the while loop is therefore never met, resulting in an infinite loop.

# Objects vs. Primitives

Question 1
What will the following code log to the console and why? 

```js
let myWord = 'Hello';
myWord.concat(' there.');

console.log(myWord);
```

Solution 1
This logs the string `'Hello'`.

The `myWord` variable is assigned to a string, which as a primitive is immutable. Calling concat on the string returns a new string with the string there. appended to it. This doesn't affect the original string, and we don't do anything with the return value.

Question 2
What will the following code log to the console and why? 

```js
let myWord = 'Hello';
myWord.repeat(3);
console.log(myWord);
myWord.replace('H', 'J');
console.log(myWord);
myWord.toUpperCase();
console.log(myWord);
```
Solution 2
Each of the `console.log()` invocations logs the string` 'Hello'`. This is the same string in each case, and it isn't affected by any of the intervening method invocations `(repeat, replace, and toUpperCase)`, each of which return a new string but don't have any effect on the original string, which is immutable. It doesn't matter which String methods we call on the string, or in which order. Strings, being primitive values, are immutable.

Question 3
What will the following code log to the console and why? 
```js
let myWords = ['Hello'];
myWords.push('Goodbye');

console.log(myWords);
```
Solution 3
This logs `[ 'Hello', 'Goodbye' ]` to the console. The value assigned to the `myWords` variable is an array. Arrays are objects and therefore mutable. The `Array.push` method mutates the array by adding an element to it, so that when we log `myWords` we get the mutated array.

Question 4
What will the following code log to the console and why? 

```js
let myWords = ['Hello'];
myWords.concat(['Goodbye']);

console.log(myWords);
```

Solution 4
This logs `[ 'Hello' ] `to the console. Although `myWords` is assigned to an array, which is an object and therefore mutable, the `Array.concat` method doesn't mutate the array it is called on; it instead returns a new array. 

Question 5
What will the following code log to the console and why? 
```js
let myWords = ['Hello'];
myWords[0].toUpperCase();

console.log(myWords);
```

Solution 5
This logs `[ 'Hello' ]` to the console. Although myWords is assigned to an array, which is an object and therefore mutable, we're actually calling the `toUpperCase()` method on the string at index `0` of the array. Being primitive types, strings are immutable, so the method has no effect on the string (it instead returns a new string), and we're not mutating the array or changing the value at index `0`.

Question 6
What will the following code log to the console and why? 
```js
let myWords = ['Hello'];
myWords[0] = myWords[0].toUpperCase();

console.log(myWords);
```

This logs `[ 'HELLO' ] `to the console. Unlike the previous example, here we are mutating the array by changing the value at index `0`. It's important to note that we aren't mutating the original string, but instead setting the value at index `0` to a new string returned by calling `String.prototype.toUpperCase` on the original string.


# Variables as Pointers

What will the following code log to the console and why? 
```js
let myWord = 'Hello';
let myOtherWord = myWord;

console.log(myWord);
console.log(myOtherWord);
```
Solution 1
This logs the string `'Hello'` twice.

The `myWord` variable is initialized to the string '`Hello`'. On line 2, we assign `myOtherWord` to `myWord`. At this point, both variables point to a string with the value of `'Hello'`; it's important to note though, even though the strings have the same value they are different strings stored at different memory addresses.

Question 2
What will the following code log to the console and why? 
```js
let myWord = 'Hello';
let myOtherWord = myWord;
myWord = 'Goodbye';

console.log(myWord);
console.log(myOtherWord);
```
Solution 2
This logs the string `'Goodbye'` and then the string `'Hello'`.

This is very similar to Exercise 1 with one key difference: on line 3 we reassign `myWord` to the string `'Goodbye'`. In JavaScript, primitive values are stored directly in the variable’s memory space. When you assign a primitive value to a variable, a new copy of that value is created and stored at a specific memory address associated with that variable. Therefore, when you assign `‘Hello’ `to `myWord` and then assign `myWord` to `myOtherWord`, both variables `myWord` and `myOtherWord` hold separate copies of the value `‘Hello’` located at different memory addresses.

Question 3
What will the following code log to the console and why? 
```js
let myWords = ['Hello', 'Goodbye'];
let myOtherWords = myWords;
myWords[0] = 'Hi';

console.log(myWords);
console.log(myOtherWords);
```
Solution 3

This will log` ['Hi', 'Goodbye']` twice. `myWords` points to a reference which points to this `['Hello', 'Goodbye']` array in memory. Then `myOtherWords` is declared and assigned `myWords`. At this point both variables point to the same array in memory location. When `mywords[0] = 'Hi'` is executed `'Hi' `is assigned to the `0` index of `mywords` array. In other words, the first element of `myWords` is changed to `'Hi'`. When both variables are logged, the change is appeared in both variables because they both point to the same array reference and arrays, being objects are mutable.

Question 4
What will the following code log to the console and why? 
Copy Code
let myWords = ['Hello', 'Goodbye'];
let myOtherWords = myWords;
myWords = ['Hi', 'Bye'];

console.log(myWords);
console.log(myOtherWords);
Solution 4
This logs the array [ 'Hi', 'Bye' ], and then the array ['Hello', 'Goodbye'].

As with Exercise 3, we're again dealing with a reference type. Again, after line 2, both variables have as their value the memory address where the array is stored. In this exercise though, line 3 reassigns the myWords variable to a different value. In this case we're reassigning it to another array, but we could equally have reassigned it to a primitive value. The important point is that the variable now points to a different value and so the two variables no longer have the same value (the memory address where the ['Hello', 'Goodbye'] array is stored). When we log each variable, different values are therefore output.

Question 5
What will the following code log to the console and why? 
```js
let myWords = ['Hello', 'Goodbye'];
let myWord = myWords[0];
myWords[0] = 'Hi';

console.log(myWords);
console.log(myWord);
```
Solution 5
This logs the array `[ 'Hi', 'Goodbye' ]`, and then the string` 'Hello'`.

On line 1 we declare and initialize the variable `myWords` to an array containing two elements, the strings `'Hello'` and `'Goodbye'`.
On line 2 we declare and initialize another variable, `myWord`, to the element at index `0` of the array referenced by `myWords`, which is the string `'Hello'`. Because that string is a primitive type, index `0` of the array and the `myWord` variable each reference different strings at different memory addresses, even though those strings have the same value.
On line 3 we reassign index `0` of the `myWords` array to a new value, the string` 'Hi'`. This changes the value stored at index `0` of the array, but has no effect on the value stored by the `myWord` variable.
When we log the value of `myWords` and `myWord` on line 5 and 6, we can see that the `myWords` array has the string `'Hi'` at index `0` and `myWord` has a value of `'Hello'`.

Question 6
What will the following code log to the console and why? 
```js
let myWords = ['Hello', 'Goodbye'];
let myWord = 'Hi';
myWords[0] = myWord;
myWord = 'Hello';

console.log(myWords);
console.log(myWord);
```
Solution 6
This logs the array `[ 'Hi', 'Goodbye' ]`, and then the string `'Hello'`.

We again begin with a `myWords` initialized to an array containing two elements, the strings `'Hello'` and `'Goodbye'`. In this case though we assign `myWord` to the string `'Hi'`, and then set the element at index `0` of the `myWords` array to the value of `myWord` before reassigning `myWord` to the string `'Hello'`.

The principles at work are the same in both exercises. The values we are dealing with are primitives, and the value of these primitive values are stored at different memory addresses. Changing the value of one does not affect the other.