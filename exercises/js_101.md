# Variable Scope
Question 1
What will the following code log to the console and why? 
```js
let num = 5;

function myFunc() {
  num = 10;
}

myFunc();
console.log(num);
```
This logs `10` to the console. The variable `num` declared and initialized to `5` on line 1 is accessible within the scope of the `myFunc` function. When that function is invoked, `num` is reassigned.
***

Question 2
What will the following code log to the console and why? 
```js
let num = 5;

function myFunc() {
  console.log(num);
  num = 10;
}

myFunc();
console.log(num);
```
This first logs `5` to the console, and then logs `10` to the console. The variable `num` declared and initialized to `5` on line 1 is accessible within the scope of the `myFunc` function. When that function is invoked it first logs the value of `num`, which at this point in execution is `5`, and then reassigns `num` to `10`. The reassigned value is then logged on the last line of the code snippet.

Question 3
```js
let num = 5;

function myFunc() {
  let num = 10;
}

myFunc();
console.log(num);
```
Solution 3
This logs `5` to the console. The variable `num` is declared and initialized to `5` on line 1. When the function is executed, however, another variable called `num` is declared and initialized within the scope of the function. The key thing here is that line 4 is the initialization of a new variable rather than the reassignment of the variable from line 1.

Question 4
What will the following code log to the console and why? 
```js
let num = 5;

function myFunc() {
  console.log(num);
  let num = 10;
}

myFunc();
console.log(num);
```
Solution 4
This won't log anything to the console. Instead, this code will raise a `ReferenceError`. The `let` declaration on line `5` creates a new num variable within the scope of the body of the `myFunc` function. The console.log on line 4 is attempting to log the value of that `num` variable, not the one declared and initialized on line one. Since the variable hasn't been initialized yet however, we get a reference error:

Question 5
What will the following code log to the console and why? 
```js
let num = 5;

function myFunc(num) {
  num = 10;
}

myFunc();
console.log(num);
```
Solution 5
This logs `5` to the console. When the `myFunc` function is invoked, due to the function parameter `num` JavaScript creates a new variable `num` within the scope of the function. This variable blocks access to the variable of the same name declared and initialized in the global scope on line 1. That variable cannot therefore be reassigned by the function and so retains its initial value of `5`, which is what is logged.

Question 6
What will the following code log to the console and why? 
```js
let num = 1;

while (num < 3) {
  num += 1;
}

console.log(num);
```
Solution 6
This logs `3` to the console.  The variable `num` declared and initialized on line 1 is incremented by 1 within the while loop on line 4 (this line essentially reassigns num to a new value, which is its current value added to 1). This happens twice, while `num` is less then `3` and so the condition for the `while` loop to execute is met. Once `num` reaches `3`, the while loop no longer runs and so program execution continues to the console.log on line 7, which logs the reassigned value of `num`.

Question 7
What will the following code log to the console and why? 
```js
let num = 1;

while (num < 3) {
  let num = 5;
  num += 1;
}

console.log(num);
```
Solution 7
This doesn't log anything to the console. This code results in an infinite loop, which will eventually time out. Line 4 declares and initializes a variable `num` to the number `5`. This is a different variable to the `num` declared and initialized to 1 on line 1, and exists within the scope of the block defined by the curly braces; it is this `num` that is incremented on line 5. The condition for the while loop, however, references the `num` declared on line 1, not the one within the scope of the block. The condition for ending the while loop is therefore never met, resulting in an infinite loop.

# Objects vs. Primitives

Question 1
What will the following code log to the console and why? 

```js
let myWord = 'Hello';
myWord.concat(' there.');

console.log(myWord);
```

Solution 1
This logs the string `'Hello'`.

The `myWord` variable is assigned to a string, which as a primitive is immutable. Calling concat on the string returns a new string with the string there. appended to it. This doesn't affect the original string, and we don't do anything with the return value.

Question 2
What will the following code log to the console and why? 

```js
let myWord = 'Hello';
myWord.repeat(3);
console.log(myWord);
myWord.replace('H', 'J');
console.log(myWord);
myWord.toUpperCase();
console.log(myWord);
```
Solution 2
Each of the `console.log()` invocations logs the string` 'Hello'`. This is the same string in each case, and it isn't affected by any of the intervening method invocations `(repeat, replace, and toUpperCase)`, each of which return a new string but don't have any effect on the original string, which is immutable. It doesn't matter which String methods we call on the string, or in which order. Strings, being primitive values, are immutable.

Question 3
What will the following code log to the console and why? 
```js
let myWords = ['Hello'];
myWords.push('Goodbye');

console.log(myWords);
```
Solution 3
This logs `[ 'Hello', 'Goodbye' ]` to the console. The value assigned to the `myWords` variable is an array. Arrays are objects and therefore mutable. The `Array.push` method mutates the array by adding an element to it, so that when we log `myWords` we get the mutated array.

Question 4
What will the following code log to the console and why? 

```js
let myWords = ['Hello'];
myWords.concat(['Goodbye']);

console.log(myWords);
```

Solution 4
This logs `[ 'Hello' ] `to the console. Although `myWords` is assigned to an array, which is an object and therefore mutable, the `Array.concat` method doesn't mutate the array it is called on; it instead returns a new array. 

Question 5
What will the following code log to the console and why? 
```js
let myWords = ['Hello'];
myWords[0].toUpperCase();

console.log(myWords);
```

Solution 5
This logs `[ 'Hello' ]` to the console. Although myWords is assigned to an array, which is an object and therefore mutable, we're actually calling the `toUpperCase()` method on the string at index `0` of the array. Being primitive types, strings are immutable, so the method has no effect on the string (it instead returns a new string), and we're not mutating the array or changing the value at index `0`.

Question 6
What will the following code log to the console and why? 
```js
let myWords = ['Hello'];
myWords[0] = myWords[0].toUpperCase();

console.log(myWords);
```

This logs `[ 'HELLO' ] `to the console. Unlike the previous example, here we are mutating the array by changing the value at index `0`. It's important to note that we aren't mutating the original string, but instead setting the value at index `0` to a new string returned by calling `String.prototype.toUpperCase` on the original string.

